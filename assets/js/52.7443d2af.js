(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{498:function(e,t,a){"use strict";a.r(t);var v=a(1),r=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"一、mvvm-是什么-和-mvc-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、mvvm-是什么-和-mvc-有什么区别"}},[e._v("#")]),e._v(" 一、mvvm 是什么，和 mvc 有什么区别")]),e._v(" "),t("ul",[t("li",[e._v("MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图（View）指的是所看到的页面。视图模型（ViewModel）是 MVVM 模式的核心，它是连接 View 和 Model 的桥梁。\n视图模型有两个方向的作用：")])]),e._v(" "),t("ol",[t("li",[e._v("将模型（Model）转化成视图（View），即将后端传递的数据转化成所看到的页面，实现的方式是：数据绑定。")]),e._v(" "),t("li",[e._v("将视图（View）转化成模型（Model），即将所看到的页面转化成后端的数据，实现的方式是：DOM 事件监听。")])]),e._v(" "),t("ul",[t("li",[e._v("当这两个方向的数据转换都实现时，我们称之为数据的双向绑定。")]),e._v(" "),t("li",[e._v("MVVM 与 MVC 最大的区别就是：MVVM 实现了 View 和 Model 的自动同步，即 Model 的属性改变时，不用再手动更改 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（双向绑定）。")])]),e._v(" "),t("h1",{attrs:{id:"二、vue2-的生命周期和-vue3-的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、vue2-的生命周期和-vue3-的生命周期"}},[e._v("#")]),e._v(" 二、vue2 的生命周期和 vue3 的生命周期")]),e._v(" "),t("ul",[t("li",[e._v("vue2 中是 beforecreate、created、beforemount、mounted、beforeupdate、updated、beforedestroy、destroyed(activated、deactivated 管理 keep-live 组件)。")]),e._v(" "),t("li",[e._v("vue3 中是 onbeforecreate、oncreated、onbeforemount、onmounted、onbeforeupdate、onupdated、onbeforeunmount、onunmounted(onactivated、ondeactivated 管理 keep-live 组件)。")])]),e._v(" "),t("h1",{attrs:{id:"三、父子组件生命周期执行顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、父子组件生命周期执行顺序"}},[e._v("#")]),e._v(" 三、父子组件生命周期执行顺序")]),e._v(" "),t("ol",[t("li",[e._v("挂载阶段\n该过程主要涉及 beforeCreate、created、beforeMount、mounted4 个钩子函数。执行顺序为：\n父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted\n一定得等子组件挂载完毕后，父组件才能挂在完毕，所以父组件的 mounted 在最后。")]),e._v(" "),t("li",[e._v("更新阶段\n该过程主要涉及 beforeUpdate、updated2 个钩子函数。注意，当父子组件有数据传递时，才有这个更新阶段执行顺序的比较。执行顺序为：\n父 beforeUpdate->子 beforeUpdate->子 updated->父 updated")]),e._v(" "),t("li",[e._v("销毁阶段\n该过程主要涉及 beforeDestroy、destroyed2 个钩子函数。执行顺序为：\n父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed")])]),e._v(" "),t("ul",[t("li",[e._v("总结：")])]),e._v(" "),t("ol",[t("li",[e._v("当父组件执行完 beforeMount 挂载开始后，会依次执行子组件中的钩子，直到全部子组件 mounted 挂载到实例上，父组件才会进入 mounted 钩子")]),e._v(" "),t("li",[e._v("子级触发事件，会先触发父级 beforeUpdate 钩子，再去触发子级 beforeUpdate 钩子，下面又是先执行子级 updated 钩子，后执行父级 updated 钩子")])]),e._v(" "),t("h1",{attrs:{id:"四、vue-平时发送异步请求在哪个生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、vue-平时发送异步请求在哪个生命周期"}},[e._v("#")]),e._v(" 四、vue 平时发送异步请求在哪个生命周期")]),e._v(" "),t("p",[e._v("我们可以在钩子函数 created、beforeMount、mounted 中进行调用异步请求，在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：能更快获取到服务端数据，减少页面加载时间，用户体验更好；SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。ps：beforeMount 和 mounted 之后进行 DOM 操作会比较安全，但在 beforeMount 之前和 unmounted 之后进行的 DOM 操作可能会导致不可预测的行为。在 beforeUpdate 和 updated 期间，修改组件的数据可能会导致无限循环的更新，应谨慎使用。")]),e._v(" "),t("h1",{attrs:{id:"五、created-和-mounted-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、created-和-mounted-区别"}},[e._v("#")]),e._v(" 五、created 和 mounted 区别")]),e._v(" "),t("ul",[t("li",[e._v("reated 生命周期钩子函数会在组件实例被创建之后立即调用，但是此时组件的模板还没有被渲染成 HTML，因此在这个时候不能访问组件中的 DOM 元素。")]),e._v(" "),t("li",[e._v("mounted 生命周期钩子函数则会在组件的模板被渲染成 HTML 之后调用，这个时候可以访问组件中的 DOM 元素。通常在这个钩子函数中进行异步请求数据、初始化插件、订阅事件等操作。")])]),e._v(" "),t("h1",{attrs:{id:"六、在-vue-中-为什么组件的-data-是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、在-vue-中-为什么组件的-data-是一个函数"}},[e._v("#")]),e._v(" 六、在 vue 中，为什么组件的 data 是一个函数")]),e._v(" "),t("ul",[t("li",[e._v("在 Vue.js 中，组件的 data 选项为什么是一个函数而不是一个对象，是为了确保每个组件实例都有一个独立的数据对象。这是因为 Vue.js 组件是可复用的，可能会在应用中多次使用。")]),e._v(" "),t("li",[e._v("当 data 是一个对象时，如果直接在组件定义中使用，那么该对象将会被所有组件实例共享。这可能导致一个组件实例中的数据变化会影响到其他组件实例，从而引发意外的 bug。")]),e._v(" "),t("li",[e._v("通过将 data 选项定义为一个函数，Vue.js 确保每个组件实例都会调用该函数返回一个全新的数据对象。这样，每个组件实例都有自己独立的数据副本，彼此之间不会相互影响。")])]),e._v(" "),t("h1",{attrs:{id:"七、v-model-是什么-有什么作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、v-model-是什么-有什么作用"}},[e._v("#")]),e._v(" 七、v-model 是什么，有什么作用？")]),e._v(" "),t("ul",[t("li",[e._v("v-model 是 Vue.js 中用于在组件和表单元素之间建立双向数据绑定的指令。它允许父组件通过 v-model 将数据传递给子组件，并在子组件内部通过修改这个数据来影响父组件的状态。v-model 的主要用途是简化组件的数据流管理，使得父子组件之间的通信更加方便。在普通的 HTML 元素上，v-model 通常用于表单元素，如"),t("code",[e._v("<input>、<textarea>、和<select>")]),e._v("。在自定义组件上，v-model 也可以通过 model 选项来自定义绑定的属性。")])]),e._v(" "),t("h1",{attrs:{id:"八、为什么-vue3-使用-proxy-代替-vue2-中的-object-defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、为什么-vue3-使用-proxy-代替-vue2-中的-object-defineproperty"}},[e._v("#")]),e._v(" 八、为什么 vue3 使用 proxy 代替 vue2 中的 Object.defineProperty")]),e._v(" "),t("ol",[t("li",[e._v("Proxy 提供了更强大丰富的 API，相对 Object.defineProperty 更灵活，proxy 可以拦截更多种类的操作，如对属性的访问、赋值和删除等。")]),e._v(" "),t("li",[e._v("Vue 3 中的响应式系统通过使用 Proxy，可以在底层进行更细粒度的拦截，避免了一些 Object.defineProperty 的性能问题。Proxy 可以直接拦截整个对象的操作，而不是像 Object.defineProperty 那样需要逐个设置属性。")]),e._v(" "),t("li",[e._v("使用 Proxy 的当你在访问一个不存在的属性时，它会抛出一个错误。这可以帮助开发者在开发过程中更早地发现潜在的问题。")]),e._v(" "),t("li",[e._v("Proxy 对于嵌套对象的处理更为自然，不需要在每一层对象上手动设置响应式。")]),e._v(" "),t("li",[e._v("Proxy 不仅可以代理现有属性，还可以代理未来动态添加的属性。这在某些场景下是非常有用的，而 Object.defineProperty 只能劫持已经存在的属性。")])]),e._v(" "),t("h1",{attrs:{id:"九、为什么-vue-数据频繁变化时-数据只更新一次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九、为什么-vue-数据频繁变化时-数据只更新一次"}},[e._v("#")]),e._v(" 九、为什么 vue 数据频繁变化时，数据只更新一次")]),e._v(" "),t("ul",[t("li",[e._v('在 Vue 中，当数据频繁变化时，Vue 并不会立即更新 DOM，而是通过一种称为"异步更新队列"的机制来批量处理数据变化。')]),e._v(" "),t("li",[e._v("Vue 的更新策略是异步的，这样可以将多个数据变化合并为一个更新，以提高性能。这个策略的核心是使用 nextTick，它会在 DOM 更新之后立即执行回调。因此，即使数据发生多次变化，Vue 会将这些变化放入队列中，然后在下一个事件循环中异步地处理它们。")]),e._v(" "),t("li",[e._v("这样做的好处是可以避免不必要的重复计算和 DOM 操作，提高性能。但也正因为这个异步更新机制，有时候在一次事件循环中，Vue 只会执行一次更新，即使数据发生了多次变化")]),e._v(" "),t("li",[e._v("如果你希望在数据变化后立即执行某些操作，可以使用 this.$nextTick或者vm.$nextTick 来等待 Vue 完成更新后再执行回调。例如：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("this.dataProperty = newValue;\nthis.$nextTick(() => {\n  // 在DOM更新之后执行的操作\n});\n")])])]),t("h1",{attrs:{id:"十、vue-的双向数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十、vue-的双向数据绑定"}},[e._v("#")]),e._v(" 十、vue 的双向数据绑定")]),e._v(" "),t("ul",[t("li",[e._v('Vue 通过使用一个称为"响应式对象"的数据结构，能够在数据发生变化时通知相关的视图更新。在 Vue 2.x 版本中，这是通过 Object.defineProperty 来实现的，而在 Vue 3.x 版本中，采用了更强大的 Proxy。')])]),e._v(" "),t("ol",[t("li",[e._v("在 Vue 2.x，当你在组件实例的 data 选项中定义数据时，Vue 会通过 Object.defineProperty 来劫持这些数据的 get 和 set 方法。这使得 Vue 能够追踪数据的变化。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Vue 2.x 数据劫持示例\nvar vm = new Vue({\n  data: {\n    message: 'Hello, Vue!'\n  }\n});\n// Vue劫持了message属性的get和set方法\nconsole.log(vm.message); // 通过get获取属性值\nvm.message = 'New Message'; // 通过set修改属性值\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("依赖追踪： 当一个属性被访问时，Vue 会追踪这个属性的依赖关系，将该组件的渲染函数与这个属性建立关联。这样，在属性发生变化时，Vue 就知道哪些组件需要重新渲染。")]),e._v(" "),t("li",[e._v("响应式更新： 当数据发生变化时，set 方法会被触发，通知相关的依赖进行更新。这也是 Vue 的“响应式”部分，它保证了数据变化时视图能够自动更新。")])]),e._v(" "),t("ul",[t("li",[e._v("Vue 3.x 中，proxy 实现双向绑定原理")])]),e._v(" "),t("ol",[t("li",[e._v("创建代理对象： 在 Vue 中，每个响应式对象都会被包装成一个 Proxy 对象。这个 Proxy 对象充当了原对象的代理，可以拦截对原对象的访问和修改。")]),e._v(" "),t("li",[e._v("拦截操作： 使用 Proxy 的核心是在创建代理对象时提供一个拦截器对象（handler）。这个拦截器对象中包含了一系列的拦截方法，例如 get、set、deleteProperty 等。这些拦截方法允许我们在对代理对象进行操作时插入自定义的逻辑。")])]),e._v(" "),t("h1",{attrs:{id:"十一、组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十一、组件通信"}},[e._v("#")]),e._v(" 十一、组件通信")]),e._v(" "),t("ol",[t("li",[e._v("父子间")])]),e._v(" "),t("ul",[t("li",[e._v("Props 和 Emit： 父组件通过 props 属性向子组件传递数据，子组件通过$emit 触发自定义事件向父组件传递数据。")]),e._v(" "),t("li",[e._v("$emit 和 $on（使用 provide 和 inject，Vue 2.x）： 父组件通过$on 监听子组件的事件，子组件通过$emit 触发事件，实现父子组件之间的通信。")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("平行组件通信")])]),e._v(" "),t("ul",[t("li",[e._v("VueX 是 Vue.js 的状态管理库，用于管理应用中的共享状态。通过 VueX，你可以在不同的组件之间共享状态，实现平行组件的通信。")]),e._v(" "),t("li",[e._v("事件总线（Event Bus）： 创建一个全局的事件总线，通过它在组件之间广播和监听事件。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);